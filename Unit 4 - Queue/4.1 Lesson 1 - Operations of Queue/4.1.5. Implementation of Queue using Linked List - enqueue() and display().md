# 4.1.5. Implementation of Queue using Linked List - enqueue() and display()
## üìã Overview
This C program implements a queue data structure using a linked list. It provides two primary operations: `enqueue()` to add elements to the queue and `display()` to print the elements in the queue. The program demonstrates a basic implementation of a queue using a linked list, which can be used in various applications such as job scheduling, message processing, and data buffering.

## üéØ Purpose
The purpose of this program is to create a queue data structure using a linked list, allowing users to add elements to the queue using the `enqueue()` function and display the elements in the queue using the `display()` function. This implementation provides a basic understanding of how a queue works and can be used as a building block for more complex applications.

## ‚ú® Key Features
* Implementation of a queue data structure using a linked list
* `enqueue()` function to add elements to the queue
* `display()` function to print the elements in the queue
* Dynamic memory allocation for each node in the linked list
* Basic error handling for memory allocation failure

## üèóÔ∏è Data Structures Used
The program uses a linked list to implement the queue data structure. A linked list is a dynamic data structure where each node (or element) points to the next node in the list. In this implementation, each node represents an element in the queue and contains two fields: `data` to store the element's value and `next` to point to the next node in the list. The linked list is defined as follows:
```c
struct queue {
    int data;
    struct queue *next;
};
```
The `struct queue` is defined with two members: `data` of type `int` to store the element's value, and `next` of type `struct queue *` to point to the next node in the list.

## üîß Implementation Details

### Algorithm Explanation
The `enqueue()` function uses the following algorithm to add an element to the queue:
1. Check if the queue is empty (both `front` and `rear` are NULL).
2. If the queue is empty, create a new node, set its `data` field to the element to be added, and set both `front` and `rear` to point to this new node.
3. If the queue is not empty, create a new node, set its `data` field to the element to be added, and update the `next` field of the current `rear` node to point to this new node. Then, update `rear` to point to the new node.

The `display()` function uses the following algorithm to print the elements in the queue:
1. Start at the `front` of the queue.
2. Traverse the linked list, printing the `data` field of each node.
3. Stop when the end of the list is reached (i.e., when `temp` becomes NULL).

### Functions Documentation
- **Function Name**: `void enqueue(int ele)`
  - **Purpose**: Adds an element to the end of the queue.
  - **Parameters**: `int ele` - the element to be added to the queue.
  - **Returns**: None (void).
  - **Logic**: Creates a new node, sets its `data` field to the element to be added, and updates the `next` field of the current `rear` node to point to this new node. If the queue is empty, sets both `front` and `rear` to point to the new node.
- **Function Name**: `void display()`
  - **Purpose**: Prints the elements in the queue.
  - **Parameters**: None.
  - **Returns**: None (void).
  - **Logic**: Traverses the linked list, printing the `data` field of each node, starting from the `front` of the queue.

## üíª Compilation & Usage

### Compilation
```bash
gcc "4.1.5. Implementation of Queue using Linked List - enqueue() and display().c" -o 4.1.5. Implementation of Queue using Linked List - enqueue() and display()
```

### Running the Program
```bash
./4.1.5. Implementation of Queue using Linked List - enqueue() and display()
```

## üì• Input/Output

### Input
The program takes an integer value as input to be added to the queue using the `enqueue()` function.

### Output
The program produces the following outputs:
* A message indicating that the element has been successfully inserted (printed by the `enqueue()` function).
* The elements in the queue (printed by the `display()` function).

## üìä Complexity Analysis
- **Time Complexity**: 
  * `enqueue()` function: O(1), as it involves a constant number of operations regardless of the size of the queue.
  * `display()` function: O(n), where n is the number of elements in the queue, as it involves traversing the entire linked list.
- **Space Complexity**: O(n), where n is the number of elements in the queue, as each element requires a separate node in the linked list.

## üß™ Example Run
```c
int main() {
    enqueue(1);
    enqueue(2);
    enqueue(3);
    display();  // Output: Elements in the queue : 1 2 3
    return 0;
}
```
Output:
```
Successfully inserted.
Successfully inserted.
Successfully inserted.
Elements in the queue : 1 2 3
```

## ‚ö†Ô∏è Edge Cases & Error Handling
The program does not handle the following edge cases:
* Memory allocation failure: If `malloc()` fails to allocate memory for a new node, the program will crash or produce undefined behavior.
* NULL pointer dereference: If `front` or `rear` is NULL, and the program attempts to access or modify the `next` or `data` fields of these pointers, it will crash or produce undefined behavior.
* Queue overflow: If the queue grows too large, it may exceed the available memory, causing the program to crash or produce undefined behavior.

## üöß Limitations
The program has the following limitations:
* Memory leak: If the program does not properly free the memory allocated for each node when the queue is emptied or when the program terminates, it may cause a memory leak.
* Lack of bounds checking: The program does not check if the queue has reached a maximum size limit, which may cause it to grow indefinitely and consume excessive memory.
* No error handling: The program does not handle errors that may occur during memory allocation, pointer dereferences, or other operations, which may cause it to crash or produce undefined behavior.

## üìù Notes
This program is a basic implementation of a queue using a linked list and is intended for educational purposes only. It may not be suitable for production use without additional error handling, bounds checking, and memory management.