# 4.1.6. Implementation of Queue using Linked List - dequeue(), size() and isEmpty()
## üìã Overview
The main purpose of this C program is to implement a queue data structure using a linked list. A queue is a First-In-First-Out (FIFO) data structure, where elements are added to the end of the queue and removed from the front of the queue. The program provides functions to perform common queue operations such as enqueue, dequeue, display, size, and isEmpty.

## üéØ Purpose
This program exists to demonstrate the implementation of a queue data structure using a linked list. It solves the problem of managing a collection of elements in a FIFO order, which is essential in various applications such as job scheduling, message processing, and data buffering. The program provides a basic framework for understanding how queues work and how they can be implemented using linked lists.

## ‚ú® Key Features
* Implementation of a queue data structure using a linked list
* Enqueue function to add elements to the end of the queue
* Dequeue function to remove elements from the front of the queue
* Display function to print all elements in the queue
* Size function to print the number of elements in the queue
* isEmpty function to check if the queue is empty

## üèóÔ∏è Data Structures Used
The program implements a queue data structure using a linked list. A linked list is a dynamic data structure where each element (called a node) points to the next element in the list. In this implementation, each node represents an element in the queue and contains an integer data field and a pointer to the next node in the list. The linked list is defined as follows:
```c
struct queue {
    int data;
    struct queue *next;
};
```
The program uses two global pointers, `front` and `rear`, to point to the front and rear of the queue, respectively.

## üîß Implementation Details

### Algorithm Explanation
The program uses the following algorithms:
* Linked list insertion algorithm: used in the `enqueue` function to add an element to the end of the queue.
* Linked list deletion algorithm: used in the `dequeue` function to remove an element from the front of the queue.
* Linked list traversal algorithm: used in the `display` and `size` functions to iterate through all elements in the queue.

### Functions Documentation
#### `enqueue(int element)`
* **Purpose**: Adds an element to the end of the queue.
* **Parameters**: `int element` - the element to be added to the queue.
* **Returns**: None (void).
* **Logic**: Creates a new node, assigns the element to the node's data field, and updates the `rear` pointer to point to the new node.

#### `dequeue()`
* **Purpose**: Removes an element from the front of the queue.
* **Parameters**: None.
* **Returns**: None (void).
* **Logic**: Checks if the queue is empty, and if not, updates the `front` pointer to point to the next node in the list and frees the memory allocated to the removed node.

#### `display()`
* **Purpose**: Prints all elements in the queue.
* **Parameters**: None.
* **Returns**: None (void).
* **Logic**: Iterates through the linked list, starting from the `front` node, and prints the data field of each node.

#### `size()`
* **Purpose**: Prints the number of elements in the queue.
* **Parameters**: None.
* **Returns**: None (void).
* **Logic**: Iterates through the linked list, starting from the `front` node, and increments a counter for each node encountered.

#### `isEmpty()`
* **Purpose**: Checks if the queue is empty.
* **Parameters**: None.
* **Returns**: None (void).
* **Logic**: Checks if the `front` pointer is NULL, and if so, prints "Queue is empty."

## üíª Compilation & Usage

### Compilation
```bash
gcc "4.1.6. Implementation of Queue using Linked List - dequeue(), size() and isEmpty().c" -o 4.1.6. Implementation of Queue using Linked List - dequeue(), size() and isEmpty()
```

### Running the Program
```bash
./4.1.6. Implementation of Queue using Linked List - dequeue(), size() and isEmpty()
```

## üì• Input/Output

### Input
The program takes an integer element as input to be added to the queue using the `enqueue` function.

### Output
The program produces the following outputs:
* "Queue is overflow." - if the queue is full and cannot accommodate more elements.
* "Queue is underflow." - if the queue is empty and cannot remove more elements.
* "Elements in the queue : " - followed by the elements in the queue.
* "Queue size : " - followed by the number of elements in the queue.
* "Queue is empty." - if the queue is empty.
* "Queue is not empty." - if the queue is not empty.

## üìä Complexity Analysis
* **Time Complexity**:
	+ `enqueue` function: O(1) - constant time complexity, as it only involves updating the `rear` pointer and allocating memory for a new node.
	+ `dequeue` function: O(1) - constant time complexity, as it only involves updating the `front` pointer and freeing memory allocated to the removed node.
	+ `display` function: O(n) - linear time complexity, as it involves iterating through all elements in the queue.
	+ `size` function: O(n) - linear time complexity, as it involves iterating through all elements in the queue.
	+ `isEmpty` function: O(1) - constant time complexity, as it only involves checking if the `front` pointer is NULL.
* **Space Complexity**:
	+ `enqueue` function: O(1) - constant space complexity, as it only involves allocating memory for a new node.
	+ `dequeue` function: O(1) - constant space complexity, as it only involves freeing memory allocated to the removed node.
	+ `display` function: O(1) - constant space complexity, as it only involves printing the elements in the queue.
	+ `size` function: O(1) - constant space complexity, as it only involves incrementing a counter.
	+ `isEmpty` function: O(1) - constant space complexity, as it only involves checking if the `front` pointer is NULL.

## üß™ Example Run
```
enqueue(1)
enqueue(2)
enqueue(3)
display() // prints "Elements in the queue : 1 2 3"
size() // prints "Queue size : 3"
dequeue() // removes the element 1 from the queue
display() // prints "Elements in the queue : 2 3"
isEmpty() // prints "Queue is not empty."
```

## ‚ö†Ô∏è Edge Cases & Error Handling
The program handles the following edge cases:
* Queue overflow: if the queue is full and cannot accommodate more elements, the `enqueue` function prints "Queue is overflow.".
* Queue underflow: if the queue is empty and cannot remove more elements, the `dequeue` function prints "Queue is underflow.".
* Empty queue: if the queue is empty, the `isEmpty` function prints "Queue is empty.".

However, the program does not handle the following edge cases:
* Null pointer dereference: if the `front` or `rear` pointer is NULL, the program may crash or produce undefined behavior.
* Memory allocation failure: if the `malloc` function fails to allocate memory, the program may crash or produce undefined behavior.

## üöß Limitations
The program has the following limitations:
* Memory leak: if the `dequeue` function is not called to remove elements from the queue, the program may leak memory.
* Null pointer dereference: if the `front` or `rear` pointer is NULL, the program may crash or produce undefined behavior.
* Limited queue size: the program does not implement a dynamic queue size, which may limit its usability in certain scenarios.
* Lack of error handling: the program does not handle errors such as null pointer dereference or memory allocation failure, which may lead to crashes or undefined behavior.

## üìù Notes
This program demonstrates a basic implementation of a queue data structure using a linked list. It provides functions for common queue operations and handles some edge cases. However, it has limitations and may require additional error handling and memory management to make it more robust and reliable.