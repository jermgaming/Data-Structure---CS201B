# 4.6.1. Write a program to insert an element in a Queue in FIFO order

## üìã Overview
This C program simulates a Queue data structure and demonstrates the insertion of elements in a First-In-First-Out (FIFO) order. The program allows users to input a series of integers, which are then added to the queue.

## üéØ Purpose
The main purpose of this program is to provide a simple implementation of a queue data structure, allowing users to understand how elements are inserted and stored in a FIFO manner. This program solves the problem of demonstrating a basic queue operation, making it useful for educational purposes or as a starting point for more complex queue-based applications.

## ‚ú® Key Features
* Implements a Queue data structure using an array
* Allows users to input a series of integers to be inserted into the queue
* Demonstrates the insertion of elements in a FIFO order
* Prints the current state of the queue after each insertion
* Handles the addition of new elements to the queue

## üèóÔ∏è Data Structures Used
The program implements a Queue data structure using an array. A queue is a linear data structure that follows the FIFO principle, where the first element added to the queue is the first one to be removed. The queue is represented by an array `arr`, and two indices `front` and `rear` are used to keep track of the front and rear elements of the queue, respectively.

## üîß Implementation Details

### Algorithm Explanation
The program uses a simple algorithm to insert elements into the queue:
1. Check if the queue is empty (i.e., `front` is -1).
2. If the queue is empty, set `front` and `rear` to 0 and add the new element to the queue.
3. If the queue is not empty, increment `rear` and add the new element to the queue.
The program repeats this process for each element to be inserted into the queue.

### Functions Documentation
- **Function Name**: `print(int arr[], int front, int rear)`
  - **Purpose**: Prints the current elements in the queue.
  - **Parameters**:
    - `arr`: The array representing the queue.
    - `front`: The index of the front element in the queue.
    - `rear`: The index of the rear element in the queue.
  - **Returns**: None (void)
  - **Logic**: The function iterates from the `front` index to the `rear` index, printing each element in the queue.
- **Function Name**: `main()`
  - **Purpose**: The entry point of the program, responsible for reading user input, inserting elements into the queue, and printing the queue after each insertion.
  - **Parameters**: None
  - **Returns**: 0 (indicating successful execution)
  - **Logic**: The function reads the number of elements to be inserted into the queue, initializes the queue, and then enters a loop to insert each element into the queue.

## üíª Compilation & Usage

### Compilation
```bash
gcc "4.6.1. Write a program to insert an element in a Queue in FIFO order.c" -o 4.6.1. Write a program to insert an element in a Queue in FIFO order
```

### Running the Program
```bash
./4.6.1. Write a program to insert an element in a Queue in FIFO order
```

## üì• Input/Output

### Input
The program expects two types of inputs:
* `n`: The number of elements to be inserted into the queue.
* `x`: The individual elements to be inserted into the queue.

### Output
The program outputs the current state of the queue after each insertion, including the elements in the queue and a message indicating that an element is being enqueued.

## üìä Complexity Analysis
- **Time Complexity**: The `print` function has a time complexity of O(n), where n is the number of elements in the queue. The `main` function has a time complexity of O(n), where n is the number of elements to be inserted into the queue. Overall, the program has a time complexity of O(n^2) due to the repeated calls to the `print` function.
- **Space Complexity**: The program uses an array of size `n` to represent the queue, resulting in a space complexity of O(n).

## üß™ Example Run
```
Enter the number of elements: 5
Enter element 1: 10
Enqueuing 10
10 
Enter element 2: 20
10 20 
Enqueuing 20
Enter element 3: 30
10 20 30 
Enqueuing 30
Enter element 4: 40
10 20 30 40 
Enqueuing 40
Enter element 5: 50
10 20 30 40 50 
Enqueuing 50
```

## ‚ö†Ô∏è Edge Cases & Error Handling
The program does not handle any edge cases or errors explicitly. However, some potential issues include:
* If the user inputs a negative value for `n`, the program will still attempt to create an array of size `n`, which may lead to undefined behavior.
* If the user inputs a value for `x` that is outside the range of the array, the program may access memory outside the bounds of the array, leading to undefined behavior.

## üöß Limitations
The program has several limitations:
* It uses a fixed-size array to represent the queue, which may lead to issues if the user needs to insert a large number of elements.
* It does not provide any mechanism for removing elements from the queue, which may limit its usefulness in certain scenarios.
* It does not handle errors or edge cases explicitly, which may lead to undefined behavior in certain situations.

## üìù Notes
This program provides a basic implementation of a queue data structure and demonstrates the insertion of elements in a FIFO order. It can be used as a starting point for more complex queue-based applications or as an educational tool to help students understand queue operations.