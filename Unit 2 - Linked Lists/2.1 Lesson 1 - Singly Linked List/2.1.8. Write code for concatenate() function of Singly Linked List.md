# üìã Overview
This C program implements a Singly Linked List (SLL) data structure and provides functions to create, concatenate, and print the linked list. The program allows users to dynamically create and add nodes to the linked list by inputting elements, and then concatenate two linked lists.

## üéØ Purpose
The purpose of this program is to demonstrate the implementation of a Singly Linked List data structure and its associated functions. The SLL is a linear data structure in which each element is a separate object, and each element (called a "node") points to the next node in the sequence. This structure allows for efficient insertion and deletion of nodes at any position in the list. The program provides functions to create and add nodes to the linked list, concatenate two linked lists, and print the elements in the linked list.

## ‚ú® Key Features
*   Dynamically creates and adds nodes to the linked list by inputting elements from the user
*   Concatenates two linked lists by linking the last node of the first linked list to the first node of the second linked list
*   Prints the elements in the linked list
*   Handles edge cases such as empty linked lists and null pointers

## üèóÔ∏è Data Structures Used
The program implements and uses the following data structures:

*   **Singly Linked List (SLL):** A linear data structure in which each element is a separate object, and each element (called a "node") points to the next node in the sequence. This structure allows for efficient insertion and deletion of nodes at any position in the list.
*   **Node:** A basic building block of the linked list, which contains an integer data field (`data`) and a pointer to the next node (`next`) in the sequence.

The `struct node` is defined as follows:
```c
struct node {
    int data;
    struct node *next;
};
typedef struct node *NODE;
```
This definition allows for the creation of nodes with integer data fields and pointers to the next node in the sequence.

## üîß Implementation Details

### Algorithm Explanation
The program uses the following algorithms:

*   **Recursive Algorithm:** The `createAndAddNodes` function uses a recursive approach to dynamically create and add nodes to the linked list.
*   **Traversal Algorithm:** The `concatenate` function uses a traversal algorithm to find the last node in the first linked list and link it to the first node of the second linked list.
*   **Linear Traversal Algorithm:** The `print` function uses a linear traversal algorithm to print the elements in the linked list.

The main logic of the program is as follows:

1.  The `createAndAddNodes` function is called to dynamically create and add nodes to the linked list.
2.  The user is prompted to input integer elements, which are used to create and add nodes to the linked list.
3.  If the user inputs -1, the creation of the linked list is terminated.
4.  The `concatenate` function is called to concatenate two linked lists.
5.  The `concatenate` function traverses the first linked list to find the last node and links it to the first node of the second linked list.
6.  The `print` function is called to print the elements in the concatenated linked list.

### Functions Documentation
The program consists of the following functions:

*   **`createAndAddNodes(NODE first)`**
    *   **Purpose:** Dynamically creates and adds nodes to the linked list by inputting elements from the user.
    *   **Parameters:** `first` (a pointer to the first node in the linked list)
    *   **Returns:** A pointer to the first node in the updated linked list
    *   **Logic:** The function uses a recursive approach to create and add nodes to the linked list. It prompts the user to input integer elements and creates a new node for each element. The function then links the new node to the end of the linked list.
*   **`concatenate(NODE t1, NODE t2)`**
    *   **Purpose:** Concatenates two linked lists by linking the last node of the first linked list to the first node of the second linked list.
    *   **Parameters:** `t1` and `t2` (pointers to the first nodes of the two linked lists to be concatenated)
    *   **Returns:** A pointer to the first node in the concatenated linked list
    *   **Logic:** The function traverses the first linked list to find the last node and links it to the first node of the second linked list.
*   **`print(NODE first)`**
    *   **Purpose:** Prints the elements in the linked list.
    *   **Parameters:** `first` (a pointer to the first node in the linked list)
    *   **Returns:** None (void function)
    *   **Logic:** The function uses a linear traversal algorithm to print the elements in the linked list. It starts at the first node and prints the data field of each node until it reaches the end of the list.

## üíª Compilation & Usage

### Compilation
To compile the program, use the following command:
```bash
gcc "2.1.8. Write code for concatenate() function of Singly Linked List.c" -o 2.1.8. Write code for concatenate() function of Singly Linked List
```
### Running the Program
To run the program, use the following command:
```bash
./2.1.8. Write code for concatenate() function of Singly Linked List
```

## üì• Input/Output

### Input
The program takes the following inputs:

*   **Integer Elements:** The user is prompted to input integer elements, which are used to create and add nodes to the linked list.
*   **-1 (Termination Input):** The user can input -1 to terminate the creation of the linked list.

### Output
The program produces the following outputs:

*   **Linked List:** The program prints the elements in the linked list.
*   **Concatenated Linked List:** The program prints the concatenated linked list after linking two linked lists.

## üìä Complexity Analysis
The time and space complexity of the program are as follows:

*   **Time Complexity:**
    *   `createAndAddNodes`: O(n), where n is the number of nodes created and added to the linked list.
    *   `concatenate`: O(m), where m is the number of nodes in the first linked list.
    *   `print`: O(n), where n is the number of nodes in the linked list.
*   **Space Complexity:**
    *   The program uses O(n) space to store the nodes in the linked list, where n is the number of nodes.

## üß™ Example Run
Here is an example run of the program:
```
Create and add nodes to list 1:
Enter element : 1
Enter element : 2
Enter element : 3
Enter element : -1
Create and add nodes to list 2:
Enter element : 4
Enter element : 5
Enter element : 6
Enter element : -1
Print list 1:
1---> 2---> 3---> NULL
Print list 2:
4---> 5---> 6---> NULL
Print concatenated list:
1---> 2---> 3---> 4---> 5---> 6---> NULL
```
## ‚ö†Ô∏è Edge Cases & Error Handling
The program handles the following edge cases:

*   **Empty Linked List:** The `print` function checks if the linked list is empty and prints a message indicating that the linked list is empty.
*   **Null Pointer:** The `concatenate` function checks if either of the input linked lists is null and returns the non-null linked list.

However, the program does not handle the following edge cases:

*   **Memory Allocation Failure:** The program does not check if memory allocation fails when creating new nodes.
*   **Invalid User Input:** The program does not validate user input and assumes that the user will input valid integer elements.

## üöß Limitations
The program has the following limitations:

*   **Memory Leak:** The program does not free the memory allocated for the nodes when the linked list is no longer needed, which can cause a memory leak.
*   **Inefficient Concatenation:** The `concatenate` function traverses the first linked list to find the last node, which can be inefficient for large linked lists.
*   **Limited Error Handling:** The program does not handle all possible error cases, such as memory allocation failure or invalid user input.

## üìù Notes
This program demonstrates the implementation of a Singly Linked List data structure and its associated functions. It provides a basic understanding of how linked lists work and how to perform common operations such as creation, concatenation, and printing. However, the program has limitations and does not handle all possible error cases, which should be considered when using it in a real-world application.