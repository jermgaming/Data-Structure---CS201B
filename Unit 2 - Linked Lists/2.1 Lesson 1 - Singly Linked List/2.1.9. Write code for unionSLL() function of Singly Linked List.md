# 2.1.9. Write code for unionSLL() function of Singly Linked List
## üìã Overview
This program implements a Singly Linked List (SLL) data structure and provides functions to create, print, concatenate, and perform a union operation on two SLLs. The union operation returns a new SLL containing all unique elements from both input lists.

## üéØ Purpose
The purpose of this program is to demonstrate the implementation of a Singly Linked List and its operations, specifically the union operation, which is a fundamental concept in computer science and data structures. The program aims to provide a clear understanding of how to create, manipulate, and combine linked lists.

## ‚ú® Key Features
*   Implementation of a Singly Linked List (SLL) data structure
*   Creation of nodes and addition to the SLL
*   Printing of elements in the SLL
*   Concatenation of two SLLs
*   Union operation on two SLLs to return a new SLL with unique elements

## üèóÔ∏è Data Structures Used
The program uses the following data structures:
*   **Singly Linked List (SLL)**: A dynamic data structure consisting of nodes, where each node contains an integer value (`data`) and a pointer to the next node (`next`).
*   **Node**: A struct representing a single element in the SLL, containing an integer value (`data`) and a pointer to the next node (`next`).

## üîß Implementation Details

### Algorithm Explanation
The union operation is performed using the following steps:
1.  Check if either of the input lists (`l1` or `l2`) is empty. If so, return the non-empty list or `NULL` if both are empty.
2.  Initialize an empty SLL (`ans`) to store the result.
3.  Iterate through the first input list (`l1`):
    *   For each node, check if the value is already present in the result SLL (`ans`) using the `find` function.
    *   If the value is not present, create a new node with the value and add it to the end of the result SLL (`ans`).
4.  Iterate through the second input list (`l2`):
    *   For each node, check if the value is already present in the result SLL (`ans`) using the `find` function.
    *   If the value is not present, create a new node with the value and add it to the end of the result SLL (`ans`).
5.  Return the resulting SLL (`ans`) containing all unique elements from both input lists.

### Functions Documentation
*   **`createAndAddNodes(NODE first)`**:
    *   **Purpose**: Creates and adds nodes to a SLL.
    *   **Parameters**: `first` - a pointer to the first node in the SLL (or `NULL` if the list is empty).
    *   **Returns**: A pointer to the first node in the updated SLL.
    *   **Logic**: Prompts the user to enter elements, creates new nodes, and adds them to the SLL.
*   **`print(NODE first)`**:
    *   **Purpose**: Prints the elements in a SLL.
    *   **Parameters**: `first` - a pointer to the first node in the SLL.
    *   **Returns**: None (void).
    *   **Logic**: Iterates through the SLL and prints the value of each node.
*   **`concatenate(NODE t1, NODE t2)`**:
    *   **Purpose**: Concatenates two SLLs.
    *   **Parameters**: `t1` and `t2` - pointers to the first nodes in the two SLLs.
    *   **Returns**: A pointer to the first node in the concatenated SLL.
    *   **Logic**: Updates the `next` pointer of the last node in the first list to point to the first node in the second list.
*   **`find(struct node* ans, int key)`**:
    *   **Purpose**: Searches for a specific value in a SLL.
    *   **Parameters**: `ans` - a pointer to the first node in the SLL, `key` - the value to search for.
    *   **Returns**: 1 if the value is found, 0 otherwise.
    *   **Logic**: Iterates through the SLL and checks if the value of each node matches the search key.
*   **`unionSLL(NODE l1, NODE l2)`**:
    *   **Purpose**: Performs a union operation on two SLLs, returning a new SLL containing all unique elements.
    *   **Parameters**: `l1` and `l2` - pointers to the first nodes in the two SLLs.
    *   **Returns**: A pointer to the first node in the resulting SLL.
    *   **Logic**: Implements the union algorithm as described above.

## üíª Compilation & Usage

### Compilation
```bash
gcc "2.1.9. Write code for unionSLL() function of Singly Linked List.c" -o 2.1.9. Write code for unionSLL() function of Singly Linked List
```

### Running the Program
```bash
./2.1.9. Write code for unionSLL() function of Singly Linked List
```

## üì• Input/Output

### Input
The program takes the following inputs:
*   Integer values to create and add nodes to the SLLs.
*   Two SLLs (`l1` and `l2`) as input to the `unionSLL` function.

### Output
The program produces the following outputs:
*   The elements in the SLLs, printed by the `print` function.
*   A new SLL containing all unique elements from both input lists, returned by the `unionSLL` function.

## üìä Complexity Analysis
*   **Time Complexity**:
    *   `createAndAddNodes`: O(n), where n is the number of nodes added to the list.
    *   `print`: O(n), where n is the number of nodes in the list.
    *   `concatenate`: O(n), where n is the number of nodes in the first list.
    *   `find`: O(n), where n is the number of nodes in the list.
    *   `unionSLL`: O(n + m), where n and m are the number of nodes in the two input lists.
*   **Space Complexity**:
    *   `createAndAddNodes`: O(n), where n is the number of nodes added to the list.
    *   `print`: O(1), as it only uses a constant amount of space to store the current node.
    *   `concatenate`: O(1), as it only updates the `next` pointer of the last node in the first list.
    *   `find`: O(1), as it only uses a constant amount of space to store the current node.
    *   `unionSLL`: O(n + m), where n and m are the number of nodes in the two input lists, as it creates a new list containing all unique elements.

## üß™ Example Run
```
Enter element : 1
Enter element : 2
Enter element : 3
Enter element : -1
Elements in the list are : 1---> 2---> 3---> NULL
Enter element : 2
Enter element : 3
Enter element : 4
Enter element : -1
Elements in the list are : 2---> 3---> 4---> NULL
Elements in the list are : 1---> 2---> 3---> 4---> NULL
```

## ‚ö†Ô∏è Edge Cases & Error Handling
The program does not handle the following edge cases:
*   **Memory allocation errors**: The program does not check for memory allocation errors when creating new nodes.
*   **Invalid input**: The program does not validate the input values or lists.
*   **Empty lists**: The program does not handle the case where both input lists are empty.

To improve the program, you can add error handling and input validation to handle these edge cases.

## üöß Limitations
The program has the following potential issues or limitations:
*   **Memory leaks**: The program does not free the memory allocated for the nodes when they are no longer needed, which can lead to memory leaks.
*   **Inefficient search**: The `find` function uses a linear search, which can be inefficient for large lists. A more efficient search algorithm, such as a binary search, can be used if the list is sorted.
*   **Limited scalability**: The program is designed to handle small to medium-sized lists. For very large lists, a more efficient data structure, such as a hash table, may be needed to improve performance.

## üìù Notes
This program is a basic implementation of a Singly Linked List and its operations. It is designed to demonstrate the concepts and algorithms used in linked list operations, particularly the union operation. The program can be improved and extended to handle larger lists, optimize performance, and add more features.