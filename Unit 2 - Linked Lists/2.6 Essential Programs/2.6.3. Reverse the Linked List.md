# 2.6.3. Reverse the Linked List
## ğŸ“‹ Overview
This C program creates a singly linked list, inserts nodes at the tail of the list, reverses the linked list, and then prints the reversed list. The program takes the number of nodes to be inserted and the data for each node as input from the user.

## ğŸ¯ Purpose
The purpose of this program is to demonstrate the implementation of a singly linked list and its reversal. It solves the problem of efficiently inserting nodes at the end of a linked list and reversing the list in a straightforward manner. This program can be used as a foundation for more complex linked list operations and serves as a learning tool for understanding linked list data structures.

## âœ¨ Key Features
* Creates a singly linked list with user-specified number of nodes
* Inserts nodes at the tail of the linked list
* Reverses the linked list
* Prints the reversed linked list
* Demonstrates basic linked list operations (insertion, reversal, traversal)

## ğŸ—ï¸ Data Structures Used
The program uses a singly linked list data structure, which is a linear data structure where each node points to the next node in the sequence. The linked list is implemented using a `struct node`, which has two members: `data` to store the node's value and `next` to point to the next node in the list.

```c
struct node {
    int data;
    struct node* next;
};
```

## ğŸ”§ Implementation Details

### Algorithm Explanation
The program uses two main algorithms:
1. **Insertion at the tail of a linked list**: This algorithm involves checking if the list is empty, and if so, creating a new node and setting it as both the head and tail of the list. If the list is not empty, a new node is created and appended to the end of the list by updating the `next` pointer of the current tail node.
2. **Reversing a linked list**: This algorithm involves iterating through the list and reversing the `next` pointers of each node. The algorithm uses three pointers: `prev`, `curr`, and `forward`, to keep track of the previous node, the current node, and the next node in the list, respectively.

### Functions Documentation
- **Function Name**: `insertAtTail(struct node** head, struct node** tail)`
  - **Purpose**: Inserts a new node at the tail of the linked list.
  - **Parameters**:
    - `head`: A pointer to the head of the linked list.
    - `tail`: A pointer to the tail of the linked list.
  - **Returns**: None (void).
  - **Logic**: Checks if the list is empty, creates a new node, and updates the `head` and `tail` pointers accordingly.

- **Function Name**: `main()`
  - **Purpose**: The entry point of the program, responsible for creating the linked list, reversing it, and printing the reversed list.
  - **Parameters**: None.
  - **Returns**: An integer indicating the program's exit status (0 for success).
  - **Logic**: Reads the number of nodes to be inserted, creates the linked list, reverses the list, and prints the reversed list.

## ğŸ’» Compilation & Usage

### Compilation
```bash
gcc "2.6.3. Reverse the Linked List.c" -o 2.6.3. Reverse the Linked List
```

### Running the Program
```bash
./2.6.3. Reverse the Linked List
```

## ğŸ“¥ Input/Output

### Input
The program takes two types of input:
* The number of nodes to be inserted (`n`).
* The data for each node (`x`).

### Output
The program produces the following output:
* The reversed linked list, printed as a sequence of integers separated by spaces.

## ğŸ“Š Complexity Analysis
- **Time Complexity**: O(n), where n is the number of nodes in the linked list. This is because the program performs a constant amount of work for each node in the list.
- **Space Complexity**: O(n), where n is the number of nodes in the linked list. This is because the program uses a linked list to store the nodes, and each node requires a constant amount of memory.

## ğŸ§ª Example Run
```
Enter the number of nodes: 5
Enter node 1: 1
Enter node 2: 2
Enter node 3: 3
Enter node 4: 4
Enter node 5: 5
Reversed list: 5 4 3 2 1
```

## âš ï¸ Edge Cases & Error Handling
The program does not handle the following edge cases:
* If the user enters a negative number for `n`, the program will still attempt to create a linked list with a negative number of nodes.
* If the user enters a non-integer value for `n` or `x`, the program will produce undefined behavior.
* If the program runs out of memory while attempting to allocate nodes, the program will produce undefined behavior.

To handle these edge cases, the program could add error checking code to validate the user's input and handle memory allocation failures.

## ğŸš§ Limitations
The program has the following potential issues or limitations:
* The program uses a singly linked list, which can be less efficient than a doubly linked list for certain operations.
* The program does not handle memory allocation failures, which can cause the program to produce undefined behavior.
* The program does not validate the user's input, which can cause the program to produce undefined behavior.

To address these issues, the program could be modified to use a doubly linked list, add error checking code to handle memory allocation failures, and validate the user's input.

## ğŸ“ Notes
This program serves as a basic example of linked list operations and can be used as a foundation for more complex data structures and algorithms. It is essential to consider the time and space complexity of the program, as well as potential edge cases and limitations, when using it in a real-world application.