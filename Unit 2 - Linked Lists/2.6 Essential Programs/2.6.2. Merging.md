# 2.6.2. Merging
## ğŸ“‹ Overview
This C program merges two sorted linked lists into a single sorted linked list. It takes the number of nodes in each list as input, followed by the node values, and then merges the two lists in ascending order.

## ğŸ¯ Purpose
The purpose of this program is to demonstrate a simple and efficient way to merge two sorted linked lists. This can be useful in various applications, such as data integration, algorithmic testing, and data processing. By providing a clear and concise implementation, this program aims to help developers understand the underlying concepts and techniques involved in merging sorted linked lists.

## âœ¨ Key Features
* Merges two sorted linked lists into a single sorted linked list
* Handles empty input lists
* Supports duplicate node values
* Provides a simple and efficient implementation using a merging algorithm

## ğŸ—ï¸ Data Structures Used
The program uses a dynamic data structure called a linked list, which consists of nodes. Each node contains an integer value (`data`) and a pointer to the next node (`next`). A custom data type (`struct node`) is defined to represent a node in the linked list.

## ğŸ”§ Implementation Details

### Algorithm Explanation
The merging algorithm works as follows:
1. Read the number of nodes in the first linked list (`n`) and the second linked list (`m`).
2. Create two empty linked lists (`n1` and `n2`) using the `insertAttaiL` function.
3. Read `n` node values and insert them into the first linked list (`n1`) using the `insertAttaiL` function.
4. Read `m` node values and insert them into the second linked list (`n2`) using the `insertAttaiL` function.
5. Initialize two temporary pointers (`t1` and `t2`) to the heads of the first and second linked lists, respectively.
6. Initialize an empty merged linked list (`ans`) using the `insertNode` function.
7. Iterate through both linked lists, comparing node values and inserting the smaller value into the merged list (`ans`).
8. If one linked list is exhausted before the other, append the remaining nodes from the non-exhausted list to the merged list (`ans`).
9. Print the merged linked list (`ans`) by iterating through its nodes and printing their values.

### Functions Documentation
- **`insertAttaiL(struct node* n1)`**:
  - **Purpose**: Inserts a new node at the end of the linked list.
  - **Parameters**: `n1` (pointer to the head of the linked list).
  - **Returns**: The updated head of the linked list (`n1`).
  - **Logic**: If the linked list is empty, create a new node and return it. Otherwise, traverse the linked list to find the last node, create a new node, and append it to the last node.
- **`insertNode(struct node* n1, int x)`**:
  - **Purpose**: Inserts a new node with value `x` at the end of the linked list.
  - **Parameters**: `n1` (pointer to the head of the linked list), `x` (integer value to be inserted).
  - **Returns**: The updated head of the linked list (`n1`).
  - **Logic**: If the linked list is empty, create a new node with value `x` and return it. Otherwise, traverse the linked list to find the last node, create a new node with value `x`, and append it to the last node.
- **`main()`**:
  - **Purpose**: The entry point of the program, responsible for reading input, merging the linked lists, and printing the output.
  - **Parameters**: None.
  - **Returns**: An integer indicating the program's exit status (0 for success).
  - **Logic**: Read input, merge the linked lists using the merging algorithm, and print the output.

## ğŸ’» Compilation & Usage

### Compilation
```bash
gcc "2.6.2. Merging.c" -o 2.6.2. Merging
```

### Running the Program
```bash
./2.6.2. Merging
```

## ğŸ“¥ Input/Output

### Input
The program expects the following input:
* The number of nodes in the first linked list (`n`)
* The number of nodes in the second linked list (`m`)
* `n` node values for the first linked list
* `m` node values for the second linked list

### Output
The program produces the following output:
* The merged linked list containing all nodes from both input lists, sorted in ascending order

## ğŸ“Š Complexity Analysis
- **Time Complexity**: The time complexity of the program is O(n + m), where n and m are the number of nodes in the input lists. This is because the merging algorithm iterates through both linked lists once, and the insertion operations have a constant time complexity.
- **Space Complexity**: The space complexity of the program is O(n + m), where n and m are the number of nodes in the input lists. This is because the program uses three linked lists: two input lists and one merged list, and the total space required is proportional to the number of nodes in the input lists.

## ğŸ§ª Example Run
```
Enter the number of nodes in the first linked list: 3
Enter the number of nodes in the second linked list: 2
Enter node values for the first linked list: 1 3 5
Enter node values for the second linked list: 2 4
Merged linked list: 1 2 3 4 5
```

## âš ï¸ Edge Cases & Error Handling
The program handles the following edge cases:
* Empty input lists: If either input list is empty, the program will still work correctly, but the merged list will only contain nodes from the non-empty list.
* Duplicate node values: If the input lists contain duplicate node values, the program will still work correctly, but the merged list may contain duplicate values.
However, the program does not handle invalid input, such as non-integer values or negative numbers.

## ğŸš§ Limitations
The program has the following limitations:
* Memory management: The program uses dynamic memory allocation to create new nodes, but it does not explicitly free the memory when the nodes are no longer needed. This can lead to memory leaks if the program is run repeatedly.
* Scalability: The program is designed to handle relatively small input lists. If the input lists are very large, the program may run out of memory or take a long time to complete.
* Error handling: The program does not provide robust error handling, which can make it difficult to diagnose and fix issues.

## ğŸ“ Notes
This program is a simple implementation of a merging algorithm for sorted linked lists. It is designed to demonstrate the underlying concepts and techniques involved in merging sorted linked lists, and it can be used as a starting point for more complex applications. However, it is essential to address the limitations and edge cases mentioned above to ensure the program is reliable and efficient in real-world scenarios.