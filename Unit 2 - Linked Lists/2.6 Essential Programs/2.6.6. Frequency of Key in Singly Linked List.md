# 2.6.6. Frequency of Key in Singly Linked List

## üìã Overview
This C program is designed to count the frequency of a given key in a singly linked list. It creates a linked list by inserting nodes at the head, then traverses the list to count the occurrences of a specified key.

## üéØ Purpose
The main purpose of this program is to solve the problem of counting the frequency of a specific key in a linked list. This is a common task in data analysis, statistics, and machine learning applications. The program demonstrates how to create a linked list, insert nodes, and traverse the list to count the occurrences of a given key.

## ‚ú® Key Features
* Creates a singly linked list by inserting nodes at the head
* Traverses the linked list to count the occurrences of a specified key
* Prints the linked list and the frequency of the key
* Demonstrates basic linked list operations such as insertion and traversal

## üèóÔ∏è Data Structures Used
The program uses a singly linked list data structure, which is a dynamic data structure consisting of nodes. Each node contains an integer data field and a pointer to the next node in the list. The linked list is defined as follows:
```c
struct node {
    int data;
    struct node* next;
};
```
The linked list is created by inserting nodes at the head using the `insertAthead` function.

## üîß Implementation Details

### Algorithm Explanation
The program uses a simple algorithm to count the frequency of a key in the linked list. The steps are as follows:
1. Create a linked list by inserting nodes at the head using the `insertAthead` function.
2. Traverse the linked list to count the occurrences of a specified key.
3. Print the linked list and the frequency of the key.

### Functions Documentation
- **`insertAthead(struct node* head)`**:
  - **Purpose**: Inserts a new node at the head of the linked list.
  - **Parameters**: `head` - a pointer to the head of the linked list.
  - **Returns**: A pointer to the updated head of the linked list.
  - **Logic**: The function reads an integer value from the user, creates a new node, and inserts it at the head of the linked list. If the list is empty, it creates a new node and returns it as the head.
- **`main()`**:
  - **Purpose**: The entry point of the program, responsible for creating the linked list, counting the frequency of a key, and printing the result.
  - **Parameters**: None.
  - **Returns**: An integer indicating the program's exit status.
  - **Logic**: The function reads the number of nodes to be inserted into the linked list, creates the linked list using the `insertAthead` function, reads the key to be searched, traverses the linked list to count the occurrences of the key, and prints the result.

## üíª Compilation & Usage

### Compilation
```bash
gcc "2.6.6. Frequency of Key in Singly Linked List.c" -o 2.6.6. Frequency of Key in Singly Linked List
```

### Running the Program
```bash
./2.6.6. Frequency of Key in Singly Linked List
```

## üì• Input/Output

### Input
The program expects the following inputs:
* The number of nodes to be inserted into the linked list (`n`)
* The data values for each node (`x`)
* The key to be searched in the linked list (`x`)

### Output
The program produces the following outputs:
* The linked list with the nodes inserted
* The frequency of the specified key in the linked list

## üìä Complexity Analysis
- **Time Complexity**: The time complexity of the program is O(n), where n is the number of nodes in the linked list. The `insertAthead` function has a time complexity of O(1), and the linked list traversal has a time complexity of O(n).
- **Space Complexity**: The space complexity of the program is O(n), where n is the number of nodes in the linked list. The program uses a dynamic linked list, which has a space complexity of O(n).

## üß™ Example Run
```
Enter the number of nodes: 5
Enter node 1: 10
Enter node 2: 20
Enter node 3: 10
Enter node 4: 30
Enter node 5: 10
Enter the key to search: 10
Given linked list: 10-->10-->30-->10-->20-->Null
Frequency of 10: 3
```

## ‚ö†Ô∏è Edge Cases & Error Handling
The program does not handle the following edge cases:
* Invalid input: The program assumes that the input values are valid integers. It does not handle cases where the input is not an integer or is outside the valid range.
* Memory allocation failure: The program does not check for memory allocation failures when creating new nodes using `malloc`.
* Empty linked list: The program does not handle the case where the linked list is empty (i.e., `n` is 0).

## üöß Limitations
The program has the following limitations:
* Memory leaks: The program does not free the allocated memory when it is no longer needed, which can lead to memory leaks.
* Limited scalability: The program uses a simple linked list implementation, which may not be suitable for large datasets or high-performance applications.
* Lack of error handling: The program does not handle errors or exceptions, which can lead to unexpected behavior or crashes.

## üìù Notes
The program is designed to demonstrate basic linked list operations and can be used as a building block for more complex data structures and algorithms. However, it is essential to address the limitations and edge cases to make the program more robust and reliable.