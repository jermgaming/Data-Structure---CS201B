# 2.6.10. Insertion and Search in SLL
## üìã Overview
The program implements a singly linked list (SLL) and provides basic operations such as insertion at the end, searching for a node, and printing the list. It allows users to interactively insert nodes, search for specific values, and print the list.

## üéØ Purpose
The purpose of this program is to demonstrate the implementation of a singly linked list and its basic operations. It solves the problem of managing a dynamic collection of data by providing a simple and efficient way to insert, search, and print nodes.

## ‚ú® Key Features
*   Insertion at the end of the linked list
*   Searching for a specific node in the linked list
*   Printing the linked list
*   Interactive user interface for inserting nodes, searching, and printing
*   Memory management for dynamic allocation and deallocation of nodes

## üèóÔ∏è Data Structures Used
The program uses a singly linked list (SLL) data structure, which is a linear data structure consisting of nodes, each containing a value and a reference (or "link") to the next node in the sequence. The SLL is implemented using a struct `Node` with two members: `data` (an integer) and `next` (a pointer to the next node).

## üîß Implementation Details

### Algorithm Explanation
The program uses the following algorithms:

*   Insertion at the end: A simple iterative algorithm that traverses the linked list to find the last node and appends a new node to it.
*   Search: A linear search algorithm that iterates through the linked list, comparing each node's value to the target value.
*   Printing: A simple iterative algorithm that traverses the linked list, printing each node's value.

### Functions Documentation
*   **`createNode`**: `createNode(int data)`
    *   **Purpose**: Creates a new node with the given `data` value.
    *   **Parameters**: `data` (an integer)
    *   **Returns**: A pointer to the newly created node.
    *   **Logic**: Allocates memory for a new node, sets its `data` member to the given value, and sets its `next` member to `NULL`.
*   **`insertAtEnd`**: `insertAtEnd(struct Node** head, int data)`
    *   **Purpose**: Inserts a new node with the given `data` value at the end of the linked list.
    *   **Parameters**: `head` (a pointer to the head of the linked list), `data` (an integer)
    *   **Returns**: None (void)
    *   **Logic**: If the linked list is empty, creates a new node and sets it as the head. Otherwise, traverses the linked list to find the last node and appends a new node to it.
*   **`searchNode`**: `searchNode(struct Node* head, int data)`
    *   **Purpose**: Searches for a node with the given `data` value in the linked list.
    *   **Parameters**: `head` (a pointer to the head of the linked list), `data` (an integer)
    *   **Returns**: An integer indicating whether the node was found (1) or not (0).
    *   **Logic**: Iterates through the linked list, comparing each node's value to the target value. If a match is found, returns 1. If the end of the list is reached without finding a match, returns 0.
*   **`printList`**: `printList(struct Node* head)`
    *   **Purpose**: Prints the values of all nodes in the linked list.
    *   **Parameters**: `head` (a pointer to the head of the linked list)
    *   **Returns**: None (void)
    *   **Logic**: Iterates through the linked list, printing each node's value.

## üíª Compilation & Usage

### Compilation
```bash
gcc "2.6.10. Insertion and Search in SLL.c" -o 2.6.10. Insertion and Search in SLL
```

### Running the Program
```bash
./2.6.10. Insertion and Search in SLL
```

## üì• Input/Output

### Input
The program expects the following inputs:

*   The number of nodes to insert
*   The values of the nodes to insert
*   User choices (integers) for searching, printing, inserting, or exiting

### Output
The program produces the following outputs:

*   The linked list (printed to the console)
*   Search results (printed to the console)
*   Confirmation messages for insertion and exit (printed to the console)

## üìä Complexity Analysis
*   **Time Complexity**:
    *   Insertion at the end: O(n), where n is the number of nodes in the linked list, because the program must traverse the entire list to find the last node.
    *   Search: O(n), where n is the number of nodes in the linked list, because the program must iterate through the entire list to find the target value.
    *   Printing: O(n), where n is the number of nodes in the linked list, because the program must iterate through the entire list to print each node's value.
*   **Space Complexity**: O(n), where n is the number of nodes in the linked list, because the program allocates memory for each node.

## üß™ Example Run
```
Number of nodes: 3
1 2 3
1. Search
2. Print List
3. Insert at End
4. Exit
Choice: 2
1 -> 2 -> 3 -> NULL
1. Search
2. Print List
3. Insert at End
4. Exit
Choice: 1
Value: 2
Found
1. Search
2. Print List
3. Insert at End
4. Exit
Choice: 3
4
4 inserted at end
1. Search
2. Print List
3. Insert at End
4. Exit
Choice: 2
1 -> 2 -> 3 -> 4 -> NULL
```

## ‚ö†Ô∏è Edge Cases & Error Handling
The program handles the following edge cases:

*   Empty linked list: The program checks for an empty list before attempting to insert or search for nodes.
*   Invalid user input: The program checks for invalid user input (e.g., non-integer values) and handles it by printing an error message.
*   Memory allocation errors: The program checks for memory allocation errors (e.g., `malloc` failures) and handles them by printing an error message.

However, the program does not handle the following edge cases:

*   Very large linked lists: The program may experience performance issues or run out of memory for very large linked lists.
*   Concurrent access: The program is not designed for concurrent access and may experience issues if multiple threads or processes attempt to access the linked list simultaneously.

## üöß Limitations
The program has the following limitations:

*   Performance: The program's insertion and search algorithms have a time complexity of O(n), which may be slow for very large linked lists.
*   Memory usage: The program allocates memory for each node, which may be a concern for very large linked lists or systems with limited memory.
*   Lack of error handling: The program does not handle all possible error cases, such as memory allocation errors or invalid user input.
*   Limited functionality: The program only provides basic insertion, search, and printing functionality, and may not be suitable for more complex use cases.

## üìù Notes
This program is intended for educational purposes and demonstrates the basic concepts of singly linked lists and their operations. It is not intended for production use and may require modifications to suit specific use cases.