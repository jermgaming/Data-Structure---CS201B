# 3.2.7. Stack Implementation Using Linked Lists
## üìã Overview
This C program implements a stack data structure using a linked list. A stack is a linear data structure that follows the Last-In-First-Out (LIFO) principle, meaning the last element added to the stack is the first one to be removed. The program provides functions to perform common stack operations such as push, pop, peek, check if the stack is empty, and display the elements of the stack.

## üéØ Purpose
The purpose of this program is to demonstrate the implementation of a stack using a linked list. Stacks are a fundamental data structure in computer science, and they have numerous applications in programming, such as evaluating postfix expressions, implementing recursive algorithms, and parsing syntax. This program provides a basic implementation of a stack, which can be used as a building block for more complex applications.

## ‚ú® Key Features
* Implement a stack data structure using a linked list
* Provide functions for push, pop, peek, check if the stack is empty, and display the elements of the stack
* Handle edge cases such as an empty stack and null pointer
* Analyze time and space complexity of each function

## üèóÔ∏è Data Structures Used
The program uses a linked list to implement the stack. A linked list is a dynamic data structure where each element (node) points to the next element in the list. In this implementation, each node represents an element in the stack and contains an integer value (`data`) and a pointer to the next node (`next`). The linked list is defined as follows:
```c
struct stack {
    int data;
    struct stack *next;
};
```
The `struct stack` is used to represent a node in the linked list, and the `next` pointer is used to point to the next node in the list.

## üîß Implementation Details

### Algorithm Explanation
The program uses the following algorithms to implement the stack operations:
* Linked list insertion (in `push()`): inserts a new node at the beginning of the linked list.
* Linked list deletion (in `pop()`): removes the first node from the linked list.
* Linked list traversal (in `display()`): traverses the linked list to print all elements.
The main logic of the program is as follows:
1. The `push()` function is called to add a new element to the stack. It checks if the stack is empty (i.e., `top` is `NULL`). If it is, a new node is created and assigned to `top`. If the stack is not empty, a new node is created and inserted at the beginning of the linked list.
2. The `pop()` function is called to remove the top element from the stack. It checks if the stack is empty. If it is, a message is printed to the console. If the stack is not empty, the top node is removed and its value is printed to the console.
3. The `peek()` function is called to return the value of the top element in the stack without removing it. It checks if the stack is empty. If it is, a message is printed to the console. If the stack is not empty, the value of the top node is printed to the console.
4. The `isEmpty()` function is called to check if the stack is empty. It checks if `top` is `NULL`. If it is, a message is printed to the console indicating that the stack is empty. If `top` is not `NULL`, a message is printed to the console indicating that the stack is not empty.
5. The `display()` function is called to print all elements in the stack to the console. It traverses the linked list, printing the value of each node.

### Functions Documentation
- **Function Name**: `push(int x)`
  - **Purpose**: Adds a new element to the top of the stack.
  - **Parameters**: `x` (the integer value to be added to the stack).
  - **Returns**: None.
  - **Logic**: If the stack is empty, a new node is created and assigned to `top`. If the stack is not empty, a new node is created and inserted at the beginning of the linked list.
- **Function Name**: `pop()`
  - **Purpose**: Removes the top element from the stack.
  - **Parameters**: None.
  - **Returns**: None.
  - **Logic**: If the stack is empty, a message is printed to the console. If the stack is not empty, the top node is removed and its value is printed to the console.
- **Function Name**: `peek()`
  - **Purpose**: Returns the value of the top element in the stack without removing it.
  - **Parameters**: None.
  - **Returns**: None (prints the value to the console).
  - **Logic**: If the stack is empty, a message is printed to the console. If the stack is not empty, the value of the top node is printed to the console.
- **Function Name**: `isEmpty()`
  - **Purpose**: Checks if the stack is empty.
  - **Parameters**: None.
  - **Returns**: None (prints a message to the console).
  - **Logic**: If `top` is `NULL`, a message is printed to the console indicating that the stack is empty. If `top` is not `NULL`, a message is printed to the console indicating that the stack is not empty.
- **Function Name**: `display()`
  - **Purpose**: Prints all elements in the stack to the console.
  - **Parameters**: None.
  - **Returns**: None.
  - **Logic**: Traverses the linked list, printing the value of each node.

## üíª Compilation & Usage

### Compilation
```bash
gcc "3.2.7. Stack Implementation Using Linked Lists.c" -o 3.2.7. Stack Implementation Using Linked Lists
```

### Running the Program
```bash
./3.2.7. Stack Implementation Using Linked Lists
```

## üì• Input/Output

### Input
The program does not have any explicit input functions. However, the `push()` function takes an integer value as input.

### Output
The program prints messages to the console to indicate the result of each operation, such as "Successfully pushed." or "Popped value = 5".

## üìä Complexity Analysis
- **Time Complexity**:
  - `push()`: O(1) (constant time) because it only involves creating a new node and updating the `top` pointer.
  - `pop()`: O(1) (constant time) because it only involves removing the top node and updating the `top` pointer.
  - `peek()`: O(1) (constant time) because it only involves accessing the top node.
  - `isEmpty()`: O(1) (constant time) because it only involves checking if `top` is `NULL`.
  - `display()`: O(n) (linear time) where n is the number of nodes in the linked list, because it involves traversing the entire linked list.
- **Space Complexity**:
  - `push()`: O(1) (constant space) because it only allocates a single node.
  - `pop()`: O(1) (constant space) because it only deallocates a single node.
  - `peek()`: O(1) (constant space) because it does not allocate or deallocate any nodes.
  - `isEmpty()`: O(1) (constant space) because it does not allocate or deallocate any nodes.
  - `display()`: O(1) (constant space) because it does not allocate or deallocate any nodes.

## üß™ Example Run
```
push(5)
Successfully pushed.
push(10)
Successfully pushed.
peek()
Peek value = 10
pop()
Popped value = 10
isEmpty()
Stack is not empty.
display()
Elements of the stack are : 5
```

## ‚ö†Ô∏è Edge Cases & Error Handling
The program handles the following edge cases:
* Empty stack: The `pop()`, `peek()`, and `display()` functions check if the stack is empty before attempting to access or remove nodes.
* Null pointer: The `push()` function checks if `top` is `NULL` before attempting to access or update it.
However, the program does not handle the following error cases:
* Memory allocation failure: The `push()` function does not check if the memory allocation for the new node fails.
* Integer overflow: The `push()` function does not check if the integer value being added to the stack is within the valid range.

## üöß Limitations
The program has the following limitations:
* Memory leak: The program does not have a function to free all nodes in the linked list when the stack is no longer needed, which can lead to a memory leak.
* Limited functionality: The program only provides basic stack operations and does not support more advanced operations such as searching or sorting.
* No error handling: The program does not handle errors such as memory allocation failure or integer overflow, which can lead to unexpected behavior or crashes.

## üìù Notes
The program is a basic implementation of a stack using a linked list, and it can be used as a building block for more complex applications. However, it has limitations and does not handle errors, so it should be used with caution.