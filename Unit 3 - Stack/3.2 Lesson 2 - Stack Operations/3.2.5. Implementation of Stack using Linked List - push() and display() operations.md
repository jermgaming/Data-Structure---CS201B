# 3.2.5. Implementation of Stack using Linked List - push() and display() operations
## üìã Overview
This C program implements a stack data structure using a linked list, providing two primary operations: `push()` to add elements to the stack and `display()` to print the elements of the stack. The stack follows the Last-In-First-Out (LIFO) principle, where the last element added is the first one to be removed.

## üéØ Purpose
The purpose of this program is to demonstrate the implementation of a stack using a linked list, which is a dynamic data structure that allows for efficient insertion and deletion of elements. This program solves the problem of managing a collection of elements in a LIFO order, which is useful in various applications such as evaluating postfix expressions, implementing recursive algorithms, and parsing syntax.

## ‚ú® Key Features
* Implementation of a stack using a linked list
* `push()` operation to add elements to the stack
* `display()` operation to print the elements of the stack
* Dynamic memory allocation using `malloc()`
* LIFO order of elements

## üèóÔ∏è Data Structures Used
The program uses two data structures:
* **Stack**: A LIFO data structure, where the last element added is the first one to be removed. The stack is implemented using a linked list.
* **Linked List**: A dynamic data structure in which each element (node) points to the next node, allowing for efficient insertion and deletion of elements. Each node in the linked list has two fields: `data` to store the element's value and `next` to point to the next node in the list.

## üîß Implementation Details
### Algorithm Explanation
The program uses the following algorithms:
* **Stack Push Algorithm**: When adding an element to the stack, it checks if the stack is empty. If it is, a new node is created and set as the top of the stack. If the stack is not empty, a new node is created, and its `next` pointer is set to the current top of the stack. The new node then becomes the top of the stack.
* **Stack Display Algorithm**: The program starts at the top of the stack and traverses the linked list, printing the `data` of each node until it reaches the end of the list (i.e., `NULL`).

### Functions Documentation
* **`push(int x)`**:
  + **Purpose**: Adds an element `x` to the top of the stack.
  + **Parameters**: `int x` (the element to be added to the stack).
  + **Returns**: `stk` (a pointer to the top of the stack after the addition).
  + **Logic**: Creates a new node, sets its `data` to `x`, and updates the `next` pointer to point to the current top of the stack. If the stack is empty, sets the new node as the top of the stack.
* **`display()`**:
  + **Purpose**: Prints the elements of the stack.
  + **Parameters**: None.
  + **Returns**: None.
  + **Logic**: Traverses the linked list, printing the `data` of each node until it reaches the end of the list (i.e., `NULL`).

## üíª Compilation & Usage
### Compilation
```bash
gcc "3.2.5. Implementation of Stack using Linked List - push() and display() operations.c" -o 3.2.5. Implementation of Stack using Linked List - push() and display() operations
```
### Running the Program
```bash
./3.2.5. Implementation of Stack using Linked List - push() and display() operations
```

## üì• Input/Output
### Input
The program takes an integer `x` as input for the `push()` function.
### Output
The program produces the following outputs:
* The `push()` function prints "Successfully pushed." to indicate that the element has been added to the stack.
* The `display()` function prints the elements of the stack, separated by spaces, followed by a newline character.

## üìä Complexity Analysis
* **Time Complexity**:
  + `push(x)`: O(1) because it involves a constant number of operations (creating a new node and updating the `top` pointer).
  + `display()`: O(n) because it involves traversing the entire linked list, where n is the number of elements in the stack.
* **Space Complexity**: O(n) because the program uses a linked list to store the elements of the stack, where n is the number of elements in the stack.

## üß™ Example Run
```
Successfully pushed.
Elements of the stack are : 10 
Successfully pushed.
Elements of the stack are : 20 10 
Successfully pushed.
Elements of the stack are : 30 20 10 
```
## ‚ö†Ô∏è Edge Cases & Error Handling
The program does not handle the following edge cases:
* **Memory Allocation Failure**: If `malloc()` fails to allocate memory for a new node, the program will not handle this error.
* **Stack Overflow**: If the stack grows too large, the program may run out of memory.
* **Invalid Input**: The program does not validate the input `x` for the `push()` function.

## üöß Limitations
The program has the following limitations:
* **Memory Leaks**: The program does not free the memory allocated for the nodes when they are removed from the stack, which can lead to memory leaks.
* **Limited Error Handling**: The program does not handle errors such as memory allocation failures or stack overflows.
* **No Pop Operation**: The program only provides a `push()` operation and does not provide a `pop()` operation to remove elements from the stack.

## üìù Notes
This program demonstrates the implementation of a stack using a linked list in C. It provides a basic understanding of how a stack works and how it can be used in various applications. However, it is essential to note that this program has limitations and does not handle edge cases, which should be considered when using this implementation in a real-world scenario.