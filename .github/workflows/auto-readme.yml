name: Auto-generate README for C files with AI

on:
  push:
    paths:
      - '**/*.c'

jobs:
  generate-readme:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install dependencies
        run: |
          pip install requests
      
      - name: Generate README files with AI
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
        run: |
          python3 << 'EOF'
          import os
          import json
          import requests
          import subprocess

          def get_modified_c_files():
              """Get list of modified/added .c files"""
              result = subprocess.run(
                  ['git', 'diff', '--name-only', '--diff-filter=AM', 'HEAD^', 'HEAD'],
                  capture_output=True,
                  text=True
              )
              files = [f for f in result.stdout.strip().split('\n') if f.endswith('.c')]
              return files

          def read_file_content(filepath):
              """Read content of a file"""
              try:
                  with open(filepath, 'r', encoding='utf-8') as f:
                      return f.read()
              except Exception as e:
                  print(f"Error reading {filepath}: {e}")
                  return None

          def generate_readme_with_groq(code_content, filename, filepath):
              """Generate detailed README using Groq API (Free) with full code context"""
              api_key = os.getenv('GROQ_API_KEY')
              
              if not api_key:
                  print("âš ï¸  GROQ_API_KEY not found. Using basic template.")
                  return None
              
              # First API call: Analyze the code deeply
              analysis_prompt = f"""You are analyzing a C program for documentation purposes. Read and understand this code completely.

          **File:** {filename}
          **Path:** {filepath}

          **COMPLETE CODE:**
          ```c
          {code_content}
          ```

          Analyze this code in detail and provide:
          1. What does this program do? (main purpose)
          2. What data structures are implemented/used?
          3. List all functions with their purpose, parameters, and return values
          4. What algorithms are used?
          5. What are the inputs and outputs?
          6. Step-by-step walkthrough of the main logic
          7. Time and space complexity analysis
          8. Any edge cases or error handling
          9. Potential issues or limitations
          10. Example use cases

          Be extremely detailed and technical. This analysis will be used to generate documentation."""

              try:
                  # Get detailed code analysis
                  print(f"ðŸ” Analyzing code context for {filename}...")
                  analysis_response = requests.post(
                      'https://api.groq.com/openai/v1/chat/completions',
                      headers={
                          'Authorization': f'Bearer {api_key}',
                          'Content-Type': 'application/json'
                      },
                      json={
                          'model': 'llama-3.3-70b-versatile',
                          'messages': [
                              {
                                  'role': 'system',
                                  'content': 'You are an expert C programmer and code analyst. Analyze code thoroughly and provide detailed technical insights.'
                              },
                              {
                                  'role': 'user',
                                  'content': analysis_prompt
                              }
                          ],
                          'temperature': 0.3,  # Lower temperature for accurate analysis
                          'max_tokens': 4000
                      },
                      timeout=45
                  )
                  
                  if analysis_response.status_code != 200:
                      print(f"âŒ Analysis failed: {analysis_response.status_code}")
                      return None
                  
                  code_analysis = analysis_response.json()['choices'][0]['message']['content']
                  print(f"âœ… Code analysis complete")
                  
                  # Second API call: Generate README based on analysis
                  readme_prompt = f"""Based on the following code analysis, create a comprehensive, well-structured README.md file.

          **CODE ANALYSIS:**
          {code_analysis}

          **ORIGINAL CODE FOR REFERENCE:**
          ```c
          {code_content}
          ```

          Create a detailed README.md with these sections:

          # {filename}

          ## ðŸ“‹ Overview
          [Clear, concise description of what this program does]

          ## ðŸŽ¯ Purpose
          [Detailed explanation of why this program exists and what problem it solves]

          ## âœ¨ Key Features
          [Bullet points of main features and capabilities]

          ## ðŸ—ï¸ Data Structures Used
          [Detailed explanation of data structures - how they're defined, how they work]

          ## ðŸ”§ Implementation Details

          ### Algorithm Explanation
          [Step-by-step breakdown of the main algorithm with clear explanations]

          ### Functions Documentation
          [Document each function:]
          - **Function Name**: `function_name(parameters)`
            - **Purpose**: What it does
            - **Parameters**: Explain each parameter
            - **Returns**: What it returns
            - **Logic**: How it works

          ## ðŸ’» Compilation & Usage

          ### Compilation
          ```bash
          gcc "{filename}.c" -o {filename}
          ```

          ### Running the Program
          ```bash
          ./{filename}
          ```

          ## ðŸ“¥ Input/Output

          ### Input
          [Describe what inputs the program expects]

          ### Output
          [Describe what outputs the program produces]

          ## ðŸ“Š Complexity Analysis
          - **Time Complexity**: [Analyze with explanation]
          - **Space Complexity**: [Analyze with explanation]

          ## ðŸ§ª Example Run
          ```
          [Show sample execution with actual expected output]
          ```

          ## âš ï¸ Edge Cases & Error Handling
          [List edge cases the code handles or should handle]

          ## ðŸš§ Limitations
          [Any known limitations or constraints]

          ## ðŸ“ Notes
          [Any additional important information]

          Use the code analysis to fill in ALL details accurately. Be specific, technical, and educational. Use emojis for section headers. Make it comprehensive and professional."""

                  print(f"ðŸ“ Generating README documentation...")
                  readme_response = requests.post(
                      'https://api.groq.com/openai/v1/chat/completions',
                      headers={
                          'Authorization': f'Bearer {api_key}',
                          'Content-Type': 'application/json'
                      },
                      json={
                          'model': 'llama-3.3-70b-versatile',
                          'messages': [
                              {
                                  'role': 'system',
                                  'content': 'You are an expert technical writer. Create clear, detailed, and well-structured documentation in Markdown format.'
                              },
                              {
                                  'role': 'user',
                                  'content': readme_prompt
                              }
                          ],
                          'temperature': 0.7,
                          'max_tokens': 8000
                      },
                      timeout=45
                  )
                  
                  if readme_response.status_code == 200:
                      print(f"âœ… README generated successfully")
                      return readme_response.json()['choices'][0]['message']['content']
                  else:
                      print(f"âŒ README generation failed: {readme_response.status_code}")
                      return None
                      
              except Exception as e:
                  print(f"âŒ Error calling Groq API: {e}")
                  return None

          def create_basic_readme(filename, filepath, code_content):
              """Fallback basic README template"""
              return f"""# {filename}

          ## Description
          This C program is located at `{filepath}`.

          ## Code
          ```c
          {code_content[:500]}...
          ```

          ## Compilation
          ```bash
          gcc "{filename}.c" -o {filename}
          ```

          ## Usage
          ```bash
          ./{filename}
          ```

          ## Notes
          - Auto-generated README (API key not configured for detailed analysis)
          - Please add detailed documentation manually
          """

          def main():
              modified_files = get_modified_c_files()
              
              if not modified_files:
                  print("No .c files modified")
                  return
              
              for filepath in modified_files:
                  if not filepath:
                      continue
                      
                  directory = os.path.dirname(filepath)
                  filename = os.path.splitext(os.path.basename(filepath))[0]
                  readme_path = os.path.join(directory, f"{filename}.md")
                  
                  # Check if README already exists
                  if os.path.exists(readme_path):
                      print(f"â„¹ï¸  {readme_path} already exists, skipping")
                      continue
                  
                  print(f"ðŸ“ Processing: {filepath}")
                  
                  # Read C file content
                  code_content = read_file_content(filepath)
                  
                  if not code_content:
                      print(f"âš ï¸  Could not read {filepath}")
                      continue
                  
                  # Generate README with AI
                  readme_content = generate_readme_with_groq(code_content, filename, filepath)
                  
                  # Fallback to basic template if AI fails
                  if not readme_content:
                      readme_content = create_basic_readme(filename, filepath, code_content)
                  
                  # Write README file
                  try:
                      with open(readme_path, 'w', encoding='utf-8') as f:
                          f.write(readme_content)
                      print(f"âœ… Created: {readme_path}")
                  except Exception as e:
                      print(f"âŒ Error writing {readme_path}: {e}")

          if __name__ == "__main__":
              main()
          EOF
      
      - name: Commit and push if changes exist
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Check if there are any changes
          if [ -n "$(git status --porcelain)" ]; then
            git add "**/*.md"
            git commit -m "ðŸ¤– Auto-generate detailed README files using AI [skip ci]"
            git push
          else
            echo "No new README files to commit"
          fi