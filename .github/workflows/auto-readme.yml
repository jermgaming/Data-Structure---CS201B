name: Auto-generate README for C files with AI

on:
  push:
    paths:
      - '**/*.c'

jobs:
  generate-readme:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install dependencies
        run: |
          pip install requests
      
      - name: Generate README files with AI
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
        run: |
          python3 << 'EOF'
          import os
          import json
          import requests
          import subprocess

          def get_modified_c_files():
              """Get list of modified/added .c files"""
              result = subprocess.run(
                  ['git', 'diff', '--name-only', '--diff-filter=AM', 'HEAD^', 'HEAD'],
                  capture_output=True,
                  text=True
              )
              files = [f for f in result.stdout.strip().split('\n') if f.endswith('.c')]
              return files

          def read_file_content(filepath):
              """Read content of a file"""
              try:
                  with open(filepath, 'r', encoding='utf-8') as f:
                      return f.read()
              except Exception as e:
                  print(f"Error reading {filepath}: {e}")
                  return None

          def generate_readme_with_groq(code_content, filename, filepath):
              """Generate detailed README using Groq API (Free) with full code context"""
              api_key = os.getenv('GROQ_API_KEY')
              
              if not api_key:
                  print("âš ï¸  GROQ_API_KEY not found. Using basic template.")
                  return None
              
              # First API call: Analyze the code deeply
              analysis_prompt = f"""You are analyzing a C program for documentation purposes. Read and understand this code completely.

          **File:** {filename}
          **Path:** {filepath}

          **COMPLETE CODE:**
          ```c
          {code_content}
          ```

          Analyze this code in detail and provide:
          1. What does this program do? (main purpose)
          2. What data structures are implemented/used?
          3. List all functions with their purpose, parameters, and return values
          4. What algorithms are used?
          5. What are the inputs and outputs?
          6. Step-by-step walkthrough of the main logic
          7. Time and space complexity analysis
          8. Any edge cases or error handling
          9. Potential issues or limitations
          10. Example use cases

          Be extremely detailed and technical. This analysis will be used to generate documentation."""

              try:
                  # Get detailed code analysis
                  print(f"ðŸ” Analyzing code context for {filename}...")
                  analysis_response = requests.post(
                      'https://api.groq.com/openai/v1/chat/completions',
                      headers={
                          'Authorization': f'Bearer {api_key}',
                          'Content-Type': 'application/json'
                      },
                      json={
                          'model': 'llama-3.3-70b-versatile',
                          'messages': [
                              {
                                  'role': 'system',
                                  'content': 'You are an expert C programmer and code analyst. Analyze code thoroughly and provide detailed technical insights.'
                              },
                              {
                                  'role': 'user',
                                  'content': analysis_prompt
                              }
                          ],
                          'temperature': 0.3,  # Lower temperature for accurate analysis
                          'max_tokens': 4000
                      },
                      timeout=45
                  )
                  
                  if analysis_response.status_code != 200:
                      print(f"âŒ Analysis failed: {analysis_response.status_code}")
                      return None
                  
                  code_analysis = analysis_response.json()['choices'][0]['message']['content']
                  print(f"âœ… Code analysis complete")
                  
                  # Second API call: Generate README based on analysis
                  readme_prompt = f"""Based on the following code analysis, create a comprehensive, well-structured README.md file.

          **CODE ANALYSIS:**
          {code_analysis}

          **ORIGINAL CODE FOR REFERENCE:**
          ```c
          {code_content}
          ```

          Create a detailed README.md with these sections:

          # {filename}

          ## ðŸ“‹ Overview
          [Clear, concise description of what this program does]

          ## ðŸŽ¯ Purpose
          [Detailed explanation of why this program exists and what problem it solves]

          ## âœ¨ Key Features
          [Bullet points of main features and capabilities]

          ## ðŸ—ï¸ Data Structures Used
          [Detailed explanation of data structures - how they're defined, how they work]

          ## ðŸ”§ Implementation Details

          ### Algorithm Explanation
          [Step-by-step breakdown of the main algorithm with clear explanations]

          ### Functions Documentation
          [Document each function:]
          - **Function Name**: `function_name(parameters)`
            - **Purpose**: What it does
            - **Parameters**: Explain each parameter
            - **Returns**: What it returns
            - **Logic**: How it works

          ## ðŸ’» Compilation & Usage

          ### Compilation
          ```bash
          gcc "{filename}.c" -o {filename}
          ```

          ### Running the Program
          ```bash
          ./{filename}
          ```

          ## ðŸ“¥ Input/Output

          ### Input
          [Describe what inputs the program expects]

          ### Output
          [Describe what outputs the program produces]

          ## ðŸ“Š Complexity Analysis
          - **Time Complexity**: [Analyze with explanation]
          - **Space Complexity**: [Analyze with explanation]

          ## ðŸ§ª Example Run
          ```
          [Show sample execution with actual expected output]
          ```

          ## âš ï¸ Edge Cases & Error Handling
          [List edge cases the code handles or should handle]

          ## ðŸš§ Limitations
          [Any known limitations or constraints]

          ## ðŸ“ Notes
          [Any additional important information]

          Use the code analysis to fill in ALL details accurately. Be specific, technical, and educational. Use emojis for section headers. Make it comprehensive and professional."""

                  print(f"ðŸ“ Generating README documentation...")
                  readme_response = requests.post(
                      'https://api.groq.com/openai/v1/chat/completions',
                      headers={
                          'Authorization': f'Bearer {api_key}',
                          'Content-Type': 'application/json'
                      },
                      json={
                          'model': 'llama-3.3-70b-versatile',
                          'messages': [
                              {
                                  'role': 'system',
                                  'content': 'You are an expert technical writer. Create clear, detailed, and well-structured documentation in Markdown format.'
                              },
                              {
                                  'role': 'user',
                                  'content': readme_prompt
                              }
                          ],
                          'temperature': 0.7,
                          'max_tokens': 8000
                      },
                      timeout=45
                  )
                  
                  if readme_response.status_code == 200:
                      print(f"âœ… README generated successfully")
                      return readme_response.json()['choices'][0]['message']['content']
                  else:
                      print(f"âŒ README generation failed: {readme_response.status_code}")
                      return None
                      
              except Exception as e:
                  print(f"âŒ Error calling Groq API: {e}")
                  return None

          def create_basic_readme(filename, filepath, code_content):
              """Fallback basic README template"""
              return f"""# {filename}

          ## Description
          This C program is located at `{filepath}`.

          ## Code
          ```c
          {code_content[:500]}...
          ```

          ## Compilation
          ```bash
          gcc "{filename}.c" -o {filename}
          ```

          ## Usage
          ```bash
          ./{filename}
          ```

          ## Notes
          - Auto-generated README (API key not configured for detailed analysis)
          - Please add detailed documentation manually
          """

          def generate_commit_message(files_processed, code_summaries):
              """Generate context-aware commit message using AI"""
              api_key = os.getenv('GROQ_API_KEY')
              
              if not api_key or not code_summaries:
                  return "ðŸ“ Auto-generate documentation for C programs [skip ci]"
              
              # Create summary of all files processed
              files_summary = "\n\n".join([
                  f"**File:** {info['filename']}\n**Path:** {info['filepath']}\n**Summary:** {info['summary']}"
                  for info in code_summaries
              ])
              
              prompt = f"""Generate a concise, specific Git commit message for auto-generated documentation.

          The following C programs had their documentation generated:

          {files_summary}

          Create a commit message that:
          1. Starts with an emoji (ðŸ“ for docs, ðŸ”— for linked lists, ðŸŒ³ for trees, ðŸ“Š for arrays, etc.)
          2. Briefly describes what documentation was added (be specific about the topic/algorithm)
          3. Mentions the number of files if more than one
          4. Ends with [skip ci]
          5. Keep it under 72 characters if possible

          Examples:
          - "ðŸ”— Add docs for singly linked list implementation [skip ci]"
          - "ðŸŒ³ Document binary search tree operations [skip ci]"
          - "ðŸ“Š Add documentation for stack and queue programs [skip ci]"

          Generate ONLY the commit message, nothing else."""

              try:
                  response = requests.post(
                      'https://api.groq.com/openai/v1/chat/completions',
                      headers={
                          'Authorization': f'Bearer {api_key}',
                          'Content-Type': 'application/json'
                      },
                      json={
                          'model': 'llama-3.3-70b-versatile',
                          'messages': [
                              {
                                  'role': 'system',
                                  'content': 'You are a Git commit message expert. Generate clear, concise, specific commit messages.'
                              },
                              {
                                  'role': 'user',
                                  'content': prompt
                              }
                          ],
                          'temperature': 0.5,
                          'max_tokens': 100
                      },
                      timeout=15
                  )
                  
                  if response.status_code == 200:
                      commit_msg = response.json()['choices'][0]['message']['content'].strip()
                      # Ensure [skip ci] is at the end
                      if '[skip ci]' not in commit_msg:
                          commit_msg += ' [skip ci]'
                      print(f"âœ… Generated commit message: {commit_msg}")
                      return commit_msg
                  else:
                      print(f"âš ï¸  Failed to generate commit message, using default")
                      return "ðŸ“ Auto-generate documentation for C programs [skip ci]"
                      
              except Exception as e:
                  print(f"âš ï¸  Error generating commit message: {e}")
                  return "ðŸ“ Auto-generate documentation for C programs [skip ci]"

          def extract_code_summary(code_content):
              """Extract a brief summary from code (first comment or main purpose)"""
              lines = code_content.split('\n')
              
              # Try to find initial comments
              summary_lines = []
              in_comment = False
              
              for line in lines[:30]:  # Check first 30 lines
                  line = line.strip()
                  
                  if line.startswith('/*'):
                      in_comment = True
                  
                  if in_comment:
                      clean_line = line.replace('/*', '').replace('*/', '').replace('*', '').strip()
                      if clean_line and not clean_line.startswith('#'):
                          summary_lines.append(clean_line)
                  
                  if '*/' in line:
                      in_comment = False
                      if summary_lines:
                          break
                  
                  if line.startswith('//'):
                      clean_line = line.replace('//', '').strip()
                      if clean_line:
                          summary_lines.append(clean_line)
              
              if summary_lines:
                  return ' '.join(summary_lines[:3])  # First 3 lines of comments
              
              # Fallback: try to infer from filename or return generic
              return "C program implementation"

          def main():
              modified_files = get_modified_c_files()
              
              if not modified_files:
                  print("No .c files modified")
                  return
              
              code_summaries = []
              
              for filepath in modified_files:
                  if not filepath:
                      continue
                      
                  directory = os.path.dirname(filepath)
                  filename = os.path.splitext(os.path.basename(filepath))[0]
                  readme_path = os.path.join(directory, f"{filename}.md")
                  
                  # Check if README already exists
                  if os.path.exists(readme_path):
                      print(f"â„¹ï¸  {readme_path} already exists, skipping")
                      continue
                  
                  print(f"ðŸ“ Processing: {filepath}")
                  
                  # Read C file content
                  code_content = read_file_content(filepath)
                  
                  if not code_content:
                      print(f"âš ï¸  Could not read {filepath}")
                      continue
                  
                  # Extract summary for commit message
                  code_summary = extract_code_summary(code_content)
                  code_summaries.append({
                      'filename': filename,
                      'filepath': filepath,
                      'summary': code_summary
                  })
                  
                  # Generate README with AI
                  readme_content = generate_readme_with_groq(code_content, filename, filepath)
                  
                  # Fallback to basic template if AI fails
                  if not readme_content:
                      readme_content = create_basic_readme(filename, filepath, code_content)
                  
                  # Write README file
                  try:
                      with open(readme_path, 'w', encoding='utf-8') as f:
                          f.write(readme_content)
                      print(f"âœ… Created: {readme_path}")
                  except Exception as e:
                      print(f"âŒ Error writing {readme_path}: {e}")
              
              # Generate smart commit message
              if code_summaries:
                  commit_message = generate_commit_message(len(modified_files), code_summaries)
                  # Write commit message to file for the next step
                  with open('/tmp/commit_message.txt', 'w') as f:
                      f.write(commit_message)
                  print(f"ðŸ’¬ Commit message: {commit_message}")

          if __name__ == "__main__":
              main()
          EOF
      
      - name: Commit and push if changes exist
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Check if there are any changes
          if [ -n "$(git status --porcelain)" ]; then
            git add "**/*.md"
            
            # Use AI-generated commit message if available
            if [ -f /tmp/commit_message.txt ]; then
              COMMIT_MSG=$(cat /tmp/commit_message.txt)
              echo "Using AI-generated commit message: $COMMIT_MSG"
              git commit -m "$COMMIT_MSG"
            else
              echo "Using default commit message"
              git commit -m "ðŸ“ Auto-generate documentation [skip ci]"
            fi
            
            git push
            echo "âœ… Documentation committed and pushed successfully"
          else
            echo "No new README files to commit"
          fi